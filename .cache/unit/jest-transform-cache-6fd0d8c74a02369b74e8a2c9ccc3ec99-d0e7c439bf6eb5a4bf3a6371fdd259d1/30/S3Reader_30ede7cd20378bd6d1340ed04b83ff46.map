{"version":3,"sources":["S3Reader.vue"],"names":[],"mappings":";;;;;;;;;AA4CA;;;;AACA;;;;AAEA;;;;AAEA;;AACA;;;;AACA;;;;AACA;;;;AACA;;AAQA;;;;;;AAEA;AACA;AACA;AADA;AAIA;;;AACA;AAIA;;;;;;AAaA;AAAA;;AACA;;AACA;AAGA;;AACA;;;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;;AACA;AAEA;;AACA;AAqIA;AAnIA;;;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AAFA;;AAMA;AAOA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;AACA;AAFA;AAMA;AACA;AAEA;AAEA;;;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA;AACA;AACA;;AAvJA;AAAA;AAPA;AACA;AACA;AACA;AACA;AAJA;AADA","sourcesContent":["<template>\n  <ErrorTooltip ref=\"error_tooltip\">\n    <v-stepper v-model=\"step\" vertical class=\"elevation-0\">\n      <v-stepper-step :complete=\"!!assumed_role\" step=\"1\">\n        Account Credentials\n      </v-stepper-step>\n\n      <AuthStepBasic\n        v-bind:access_token.sync=\"access_token\"\n        v-bind:secret_token.sync=\"secret_token\"\n        @auth-basic=\"handle_basic\"\n        @goto-mfa=\"handle_goto_mfa\"\n      />\n\n      <v-stepper-step\n        :complete=\"!!assumed_role && assumed_role.from_mfa\"\n        step=\"2\"\n      >\n        MFA Authorization\n      </v-stepper-step>\n\n      <AuthStepMFA\n        v-bind:mfa_token.sync=\"mfa_token\"\n        v-bind:mfa_serial.sync=\"mfa_serial\"\n        @auth-mfa=\"handle_proceed_mfa\"\n        @exit-mfa=\"handle_cancel_mfa\"\n      />\n\n      <v-stepper-step step=\"3\">\n        Browse Bucket\n      </v-stepper-step>\n\n      <FileList\n        :auth=\"assumed_role\"\n        :files=\"files\"\n        @exit-list=\"handle_cancel_mfa\"\n        @got-files=\"got_files\"\n        @load-bucket=\"load_bucket\"\n      />\n    </v-stepper>\n  </ErrorTooltip>\n</template>\n\n<script lang=\"ts\">\nimport Vue from \"vue\";\nimport Component from \"vue-class-component\";\nimport { getModule } from \"vuex-module-decorators\";\nimport S3, { ObjectKey } from \"aws-sdk/clients/s3\";\nimport { AWSError } from \"aws-sdk/lib/error\";\nimport { LocalStorageVal } from \"../../../../utilities/helper_util\";\nimport FileList from \"@/components/global/upload_tabs/aws/FileList.vue\";\nimport AuthStepMFA from \"@/components/global/upload_tabs/aws/AuthStepMFA.vue\";\nimport AuthStepBasic from \"@/components/global/upload_tabs/aws/AuthStepBasic.vue\";\nimport {\n  Auth,\n  transcribe_error,\n  get_session_token,\n  MFA_Info,\n  AUTH_DURATION\n} from \"../../../../utilities/aws_util\";\nimport InspecIntakeModule, { FileID } from \"@/store/report_intake\";\nimport ErrorTooltip from \"../../../generic/ErrorTooltip.vue\";\n\n// We declare the props separately to make props types inferable.\nconst Props = Vue.extend({\n  props: {}\n});\n\n/** The cached session info */\nconst local_session_information = new LocalStorageVal<Auth | null>(\n  \"aws_session_info\"\n);\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    AuthStepBasic,\n    AuthStepMFA,\n    FileList,\n    ErrorTooltip\n  }\n})\nexport default class S3Reader extends Props {\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  req_rule = (v: string | null | undefined) =>\n    (v || \"\").trim().length > 0 || \"Field is Required\";\n\n  /** Passed from step 1 to step 2 (MFA) if necessary */\n  /** State of all globally relevant fields */\n  access_token: string = \"\";\n  secret_token: string = \"\";\n  mfa_serial: string = \"\";\n  mfa_token: string = \"\";\n\n  /** Our session information, generated by AWS STS */\n  assumed_role: Auth | null = null;\n\n  /** Current step */\n  step: number = 1;\n\n  /** Currently loaded file list from bucket */\n  files: S3.Object[] = [];\n\n  /**\n   * Logs out of current auth stage\n   */\n  logout() {\n    this.assumed_role = null;\n    this.mfa_token = \"\";\n  }\n\n  /**\n   * Handle a basic login.\n   * Gets a session token\n   */\n  handle_basic() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(this.access_token, this.secret_token, AUTH_DURATION).then(\n      // Success of get session token - now need to determine if MFA necessary\n      success => {\n        this.assumed_role = success;\n        this.step = 3;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      failure => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** If the user tries to login by going to MFA, first check that the account is valid */\n  handle_goto_mfa() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    // Don't need the duration to be very long\n    get_session_token(this.access_token, this.secret_token, 10).then(\n      // Success of get session token - now need to determine if MFA necessary\n      success => {\n        this.step = 2;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      failure => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  handle_cancel_mfa() {\n    this.step = 1;\n    this.mfa_token = \"\";\n    this.assumed_role = null; // Just in case\n  }\n\n  handle_exit_list() {\n    this.step = 1;\n    this.mfa_token = \"\";\n    this.assumed_role = null;\n    this.files = []; // Just in case\n  }\n\n  /** Handle an MFA login.\n   * Determine whether further action is necessary\n   */\n  handle_proceed_mfa() {\n    // Build our mfa params\n    let mfa: MFA_Info = {\n      SerialNumber: this.mfa_serial || null,\n      TokenCode: this.mfa_token\n    };\n\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(\n      this.access_token,\n      this.secret_token,\n      AUTH_DURATION,\n      mfa\n    ).then(\n      success => {\n        // Keep them\n        this.assumed_role = success;\n        this.step = 3;\n      },\n      failure => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our session, if there is one\n    this.assumed_role = local_session_information.get_default(null);\n    if (this.assumed_role) {\n      this.step = 3;\n    }\n  }\n\n  /** Attempt to load.\n   * Basically just wraps fetch_files with error handling\n   */\n  async load_bucket(name: string) {\n    let s3 = new S3(this.assumed_role!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,\n        MaxKeys: 100\n      })\n      .promise()\n      .then(success => {\n        this.files = success.Contents || [];\n      })\n      .catch(failure => this.handle_error(failure));\n  }\n\n  /** Save the current credentials to local storage */\n  save_creds() {\n    local_session_information.set(this.assumed_role);\n  }\n\n  /** Callback to handle an AWS error.\n   * Sets shown error.\n   */\n  handle_error(error: any): void {\n    let t_error = error as AWSError;\n    let formatted_error = transcribe_error(t_error);\n    let queue = this.$refs[\"error_tooltip\"] as ErrorTooltip;\n    queue.show_error(formatted_error);\n  }\n\n  /** Callback on got files */\n  got_files(files: Array<FileID>) {\n    this.$emit(\"got-files\", files);\n  }\n}\n</script>\n"]}