4a4c13a5d3222e1af78abc97dcbe601d
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tslib = require("tslib");

var _vue = require("vue");

var _vue2 = _interopRequireDefault(_vue);

var _vueClassComponent = require("vue-class-component");

var _vueClassComponent2 = _interopRequireDefault(_vueClassComponent);

var _s = require("aws-sdk/clients/s3");

var _s2 = _interopRequireDefault(_s);

var _helper_util = require("../../../../utilities/helper_util");

var _FileList = require("@/components/global/upload_tabs/aws/FileList.vue");

var _FileList2 = _interopRequireDefault(_FileList);

var _AuthStepMFA = require("@/components/global/upload_tabs/aws/AuthStepMFA.vue");

var _AuthStepMFA2 = _interopRequireDefault(_AuthStepMFA);

var _AuthStepBasic = require("@/components/global/upload_tabs/aws/AuthStepBasic.vue");

var _AuthStepBasic2 = _interopRequireDefault(_AuthStepBasic);

var _aws_util = require("../../../../utilities/aws_util");

var _ErrorTooltip = require("../../../generic/ErrorTooltip.vue");

var _ErrorTooltip2 = _interopRequireDefault(_ErrorTooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// We declare the props separately to make props types inferable.
const Props = _vue2.default.extend({
  props: {}
});
/** The cached session info */


const local_session_information = new _helper_util.LocalStorageVal("aws_session_info");
/**
 * File reader component for taking in inspec JSON data.
 * Uploads data to the store with unique IDs asynchronously as soon as data is entered.
 * Emits "got-files" with a list of the unique_ids of the loaded files.
 */

let S3Reader = class S3Reader extends Props {
  constructor() {
    super(...arguments);
    /** Form required field rules. Maybe eventually expand to other stuff */

    this.req_rule = v => (v || "").trim().length > 0 || "Field is Required";
    /** Passed from step 1 to step 2 (MFA) if necessary */

    /** State of all globally relevant fields */


    this.access_token = "";
    this.secret_token = "";
    this.mfa_serial = "";
    this.mfa_token = "";
    /** Our session information, generated by AWS STS */

    this.assumed_role = null;
    /** Current step */

    this.step = 1;
    /** Currently loaded file list from bucket */

    this.files = [];
  }
  /**
   * Logs out of current auth stage
   */


  logout() {
    this.assumed_role = null;
    this.mfa_token = "";
  }
  /**
   * Handle a basic login.
   * Gets a session token
   */


  handle_basic() {
    // Attempt to assume role based on if we've determined 2fa necessary
    (0, _aws_util.get_session_token)(this.access_token, this.secret_token, _aws_util.AUTH_DURATION).then( // Success of get session token - now need to determine if MFA necessary
    success => {
      this.assumed_role = success;
      this.step = 3;
    }, // Failure of initial get session token: want to set error normally
    failure => {
      this.handle_error(failure);
    });
  }
  /** If the user tries to login by going to MFA, first check that the account is valid */


  handle_goto_mfa() {
    // Attempt to assume role based on if we've determined 2fa necessary
    // Don't need the duration to be very long
    (0, _aws_util.get_session_token)(this.access_token, this.secret_token, 10).then( // Success of get session token - now need to determine if MFA necessary
    success => {
      this.step = 2;
    }, // Failure of initial get session token: want to set error normally
    failure => {
      this.handle_error(failure);
    });
  }

  handle_cancel_mfa() {
    this.step = 1;
    this.mfa_token = "";
    this.assumed_role = null; // Just in case
  }

  handle_exit_list() {
    this.step = 1;
    this.mfa_token = "";
    this.assumed_role = null;
    this.files = []; // Just in case
  }
  /** Handle an MFA login.
   * Determine whether further action is necessary
   */


  handle_proceed_mfa() {
    // Build our mfa params
    let mfa = {
      SerialNumber: this.mfa_serial || null,
      TokenCode: this.mfa_token
    }; // Attempt to assume role based on if we've determined 2fa necessary

    (0, _aws_util.get_session_token)(this.access_token, this.secret_token, _aws_util.AUTH_DURATION, mfa).then(success => {
      // Keep them
      this.assumed_role = success;
      this.step = 3;
    }, failure => {
      this.handle_error(failure);
    });
  }
  /** On mount, try to look up stored auth info */


  mounted() {
    // Load our session, if there is one
    this.assumed_role = local_session_information.get_default(null);

    if (this.assumed_role) {
      this.step = 3;
    }
  }
  /** Attempt to load.
   * Basically just wraps fetch_files with error handling
   */


  async load_bucket(name) {
    let s3 = new _s2.default(this.assumed_role.creds);
    await s3.listObjectsV2({
      Bucket: name,
      MaxKeys: 100
    }).promise().then(success => {
      this.files = success.Contents || [];
    }).catch(failure => this.handle_error(failure));
  }
  /** Save the current credentials to local storage */


  save_creds() {
    local_session_information.set(this.assumed_role);
  }
  /** Callback to handle an AWS error.
   * Sets shown error.
   */


  handle_error(error) {
    let t_error = error;
    let formatted_error = (0, _aws_util.transcribe_error)(t_error);
    let queue = this.$refs["error_tooltip"];
    queue.show_error(formatted_error);
  }
  /** Callback on got files */


  got_files(files) {
    this.$emit("got-files", files);
  }

};
S3Reader = (0, _tslib.__decorate)([(0, _vueClassComponent2.default)({
  components: {
    AuthStepBasic: _AuthStepBasic2.default,
    AuthStepMFA: _AuthStepMFA2.default,
    FileList: _FileList2.default,
    ErrorTooltip: _ErrorTooltip2.default
  }
})], S3Reader);
exports.default = S3Reader; //# sourceMappingURL=module.jsx.map
})()
var defaultExport = (module.exports.__esModule) ? module.exports.default : module.exports;var __vue__options__ = (typeof defaultExport === "function"? defaultExport.options: defaultExport)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ErrorTooltip',{ref:"error_tooltip"},[_c('v-stepper',{staticClass:"elevation-0",attrs:{"vertical":""},model:{value:(_vm.step),callback:function ($$v) {_vm.step=$$v},expression:"step"}},[_c('v-stepper-step',{attrs:{"complete":!!_vm.assumed_role,"step":"1"}},[_vm._v("\n      Account Credentials\n    ")]),_vm._v(" "),_c('AuthStepBasic',{attrs:{"access_token":_vm.access_token,"secret_token":_vm.secret_token},on:{"update:access_token":function($event){_vm.access_token=$event},"update:secret_token":function($event){_vm.secret_token=$event},"auth-basic":_vm.handle_basic,"goto-mfa":_vm.handle_goto_mfa}}),_vm._v(" "),_c('v-stepper-step',{attrs:{"complete":!!_vm.assumed_role && _vm.assumed_role.from_mfa,"step":"2"}},[_vm._v("\n      MFA Authorization\n    ")]),_vm._v(" "),_c('AuthStepMFA',{attrs:{"mfa_token":_vm.mfa_token,"mfa_serial":_vm.mfa_serial},on:{"update:mfa_token":function($event){_vm.mfa_token=$event},"update:mfa_serial":function($event){_vm.mfa_serial=$event},"auth-mfa":_vm.handle_proceed_mfa,"exit-mfa":_vm.handle_cancel_mfa}}),_vm._v(" "),_c('v-stepper-step',{attrs:{"step":"3"}},[_vm._v("\n      Browse Bucket\n    ")]),_vm._v(" "),_c('FileList',{attrs:{"auth":_vm.assumed_role,"files":_vm.files},on:{"exit-list":_vm.handle_cancel_mfa,"got-files":_vm.got_files,"load-bucket":_vm.load_bucket}})],1)],1)}
__vue__options__.staticRenderFns = []
