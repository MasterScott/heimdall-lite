{"file":"/Users/sjoshi/test/heimdall-lite/src/store/report_intake.ts","mappings":";AAAA;;GAEG;;;AAEH,uCAAiC;AACjC,mEAA+E;AAC/E,4EAA4C;AAC5C,kEAAkC;AAClC,uDAAyD;AAiDzD,IAAM,kBAAkB,GAAxB,MAAM,kBAAmB,SAAQ,mCAAU;IACzC;;OAEG;IAEH,KAAK,CAAC,QAAQ,CAAC,OAAwB;QACrC,IAAI,IAAI,GAAG,4BAAe,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACzC,OAAO,IAAI;aACR,IAAI,CAAC,IAAI,CAAC,EAAE,CACX,IAAI,CAAC,QAAQ,CAAC;YACZ,IAAI;YACJ,SAAS,EAAE,OAAO,CAAC,SAAS;YAC5B,QAAQ,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI;SAC5B,CAAC,CACH;aACA,IAAI,CAAC,GAAG,CAAC,EAAE;YACV,OAAO,GAAG,CAAC;QACb,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;OAGG;IAEH,KAAK,CAAC,QAAQ,CAAC,OAAwB;QACrC,OAAO,CAAC,GAAG,CAAC,aAAa,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QAC1C,uBAAuB;QACvB,MAAM,IAAI,GAAG,kCAAS,CAAC,oBAAU,EAAE,eAAK,CAAC,CAAC;QAE1C,aAAa;QACb,IAAI,MAA8B,CAAC;QACnC,IAAI;YACF,MAAM,GAAG,gBAAK,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SAC1C;QAAC,OAAO,CAAC,EAAE;YACV,OAAO,CAAC,GAAG,CACT,0BAA0B,OAAO,CAAC,QAAQ,kBAAkB,CAAC,IAAI,CAClE,CAAC;YACF,OAAO,IAAI,KAAK,CACd,0BAA0B,OAAO,CAAC,QAAQ,kBAAkB,CAAC,IAAI,CAClE,CAAC;SACH;QAED,+DAA+D;QAC/D,IAAI,MAAM,CAAC,cAAc,CAAC,EAAE;YAC1B,iBAAiB;YACjB,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;YAC5B,IAAI,SAAS,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;YACvC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACrC,IAAI,UAAU,GAAG;gBACf,SAAS,EAAE,OAAO,CAAC,SAAS;gBAC5B,QAAQ,EAAE,OAAO,CAAC,QAAQ;gBAC1B,SAAS;aACV,CAAC;YACF,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;YAC5B,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;SAC/B;aAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC,EAAE;YACpC,oBAAoB;YACpB,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAC1B,IAAI,OAAO,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC;YACxC,IAAI,WAAW,GAAG;gBAChB,SAAS,EAAE,OAAO,CAAC,SAAS;gBAC5B,QAAQ,EAAE,OAAO,CAAC,QAAQ;gBAC1B,OAAO;aACR,CAAC;YACF,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAC1B,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;SAC9B;aAAM;YACL,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAC1B,OAAO,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;SACzC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;CACF,CAAA;AApEC;IADC,+BAAM;kDAcN;AAOD;IADC,+BAAM;kDAgDN;AAxEG,kBAAkB;IANvB,+BAAM,CAAC;QACN,UAAU,EAAE,IAAI;QAChB,OAAO,EAAE,IAAI;QACb,KAAK,EAAE,eAAK;QACZ,IAAI,EAAE,QAAQ;KACf,CAAC;GACI,kBAAkB,CAyEvB;AAED,kBAAe,kBAAkB,CAAC;AAElC,yBAAyB;AACzB,IAAI,sBAAsB,GAAW,CAAC,CAAC;AAEvC;;;;;GAKG;AACH,SAAgB,iBAAiB;IAC/B,sBAAsB,IAAI,CAAC,CAAC;IAC5B,OAAO,sBAAsB,CAAC;AAChC,CAAC;AAHD,8CAGC","names":[],"sources":["/Users/sjoshi/test/heimdall-lite/src/store/report_intake.ts"],"sourcesContent":["/**\n * Reads and parses inspec files\n */\n\nimport { parse } from \"inspecjs\";\nimport { Module, VuexModule, getModule, Action } from \"vuex-module-decorators\";\nimport DataModule from \"@/store/data_store\";\nimport Store from \"@/store/store\";\nimport { read_file_async } from \"@/utilities/async_util\";\n\n/** Each FileID corresponds to a unique File in this store */\nexport type FileID = number;\n\n/** Represents the minimum data to represent an uploaded file handle. */\nexport type InspecFile = {\n  /**\n   * Unique identifier for this file. Used to encode which file is currently selected, etc.\n   *\n   * Note that in general one can assume that if a file A is loaded AFTER a file B, then\n   * A.unique_id > B.unique_id.\n   * Using this property, one might order files by order in which they were added.\n   */\n  unique_id: FileID;\n  /** The filename that this file was uploaded under. */\n  filename: string;\n};\n\n/** Represents a file containing an Inspec Execution output */\nexport type EvaluationFile = InspecFile & { execution: parse.AnyExec };\n/** Represents a file containing an Inspec Profile (not run) */\nexport type ProfileFile = InspecFile & { profile: parse.AnyProfile };\n\nexport type FileLoadOptions = {\n  /** The file to load */\n  file: File;\n\n  /** The unique id to grant it */\n  unique_id: FileID;\n};\n\nexport type TextLoadOptions = {\n  /** The filename to denote this object with */\n  filename: string;\n\n  /** The unique id to grant it */\n  unique_id: FileID;\n\n  /** The text to use for it. */\n  text: string;\n};\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: \"intake\"\n})\nclass InspecIntakeModule extends VuexModule {\n  /**\n   * Load a file with the specified options. Promises an error message on failure\n   */\n  @Action\n  async loadFile(options: FileLoadOptions): Promise<Error | null> {\n    let read = read_file_async(options.file);\n    return read\n      .then(text =>\n        this.loadText({\n          text,\n          unique_id: options.unique_id,\n          filename: options.file.name\n        })\n      )\n      .then(err => {\n        return err;\n      });\n  }\n\n  /*\n   * Due to issues with catching errors from Actions, this function returns its\n   * errors. null implies the text load was successful.\n   */\n  @Action\n  async loadText(options: TextLoadOptions): Promise<Error | null> {\n    console.log(\"Load Text: \" + options.text);\n    // Fetch our data store\n    const data = getModule(DataModule, Store);\n\n    // Convert it\n    let result: parse.ConversionResult;\n    try {\n      result = parse.convertFile(options.text);\n    } catch (e) {\n      console.log(\n        `Failed to convert file ${options.filename} due to error \"${e}\".`\n      );\n      return new Error(\n        `Failed to convert file ${options.filename} due to error \"${e}\".`\n      );\n    }\n\n    // Determine what sort of file we (hopefully) have, then add it\n    if (result[\"1_0_ExecJson\"]) {\n      // Handle as exec\n      console.log(\"is Execution\");\n      let execution = result[\"1_0_ExecJson\"];\n      execution = Object.freeze(execution);\n      let reportFile = {\n        unique_id: options.unique_id,\n        filename: options.filename,\n        execution\n      };\n      console.log(\"addExecution\");\n      data.addExecution(reportFile);\n    } else if (result[\"1_0_ProfileJson\"]) {\n      // Handle as profile\n      console.log(\"is Profile\");\n      let profile = result[\"1_0_ProfileJson\"];\n      let profileFile = {\n        unique_id: options.unique_id,\n        filename: options.filename,\n        profile\n      };\n      console.log(\"addProfile\");\n      data.addProfile(profileFile);\n    } else {\n      console.log(\"is Nothing\");\n      return new Error(\"Couldn't parse data\");\n    }\n    return null;\n  }\n}\n\nexport default InspecIntakeModule;\n\n// Track granted file ids\nlet last_granted_unique_id: number = 0;\n\n/**\n * Yields a guaranteed currently free file ID.\n * This is the computed as the highest currently held file id + 1\n * It does not \"fill spaces\" of closed files, so that in any given\n * session we will never repeat a file ID with a different file object.\n */\nexport function next_free_file_ID(): FileID {\n  last_granted_unique_id += 1;\n  return last_granted_unique_id;\n}\n"],"version":3}