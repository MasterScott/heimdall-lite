{"file":"/Users/sjoshi/test/heimdall-lite/src/store/data_filters.ts","mappings":"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","names":[],"sources":["/Users/sjoshi/test/heimdall-lite/src/store/data_filters.ts"],"sourcesContent":["/**\n * This module provides a cached, reusable method for filtering data from data_store.\n */\n\nimport { Module, VuexModule, getModule } from \"vuex-module-decorators\";\nimport DataModule, {\n  SourcedContextualizedProfile,\n  SourcedContextualizedEvaluation,\n  isFromProfileFile\n} from \"@/store/data_store\";\nimport { ControlStatus, Severity } from \"inspecjs\";\nimport { FileID } from \"@/store/report_intake\";\nimport Store from \"@/store/store\";\nimport LRUCache from \"lru-cache\";\nimport { context, nist } from \"inspecjs\";\n\nconst MAX_CACHE_ENTRIES = 20;\n\n/** Contains common filters on data from the store. */\nexport interface Filter {\n  // General\n  /** Which file these objects came from. Undefined => any */\n  fromFile?: FileID;\n\n  // Control specific\n  /** What status the controls can have. Undefined => any */\n  status?: ControlStatus;\n\n  /** What severity the controls can have. Undefined => any */\n  severity?: Severity;\n\n  /** Whether or not to allow/include overlayed controls */\n  omit_overlayed_controls?: boolean;\n\n  /** A search term string, case insensitive\n   * We look for this in\n   * - control ID\n   * - rule title\n   * - severity\n   * - status\n   * - finding details (from HDF)\n   * - code\n   */\n  search_term?: string;\n\n  /** The current state of the Nist Treemap. Used to further filter by nist categories etc. */\n  tree_filters?: TreeMapState;\n\n  /** A specific control id */\n  control_id?: string;\n}\n\nexport type TreeMapState = string[]; // Representing the current path spec, from root\n\n/**\n * Facillitates the search functionality\n * @param term The string to search with\n * @param context_control The control to search for term in\n */\nfunction contains_term(\n  context_control: context.ContextualizedControl,\n  term: string\n): boolean {\n  let as_hdf = context_control.root.hdf;\n  // Get our (non-null) searchable data\n  let searchables: string[] = [\n    as_hdf.wraps.id,\n    as_hdf.wraps.title,\n    as_hdf.wraps.code,\n    as_hdf.severity,\n    as_hdf.status,\n    as_hdf.finding_details\n  ].filter(s => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some(s => s.toLowerCase().includes(term));\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: \"filteredData\"\n})\nclass FilteredDataModule extends VuexModule {\n  private get dataStore(): DataModule {\n    return getModule(DataModule, Store);\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all profiles from the specified file id.\n   * Filters only based on the file ID\n   */\n  get profiles(): (file: FileID) => readonly context.ContextualizedProfile[] {\n    // Setup a cache for this run\n    const depends = this.dataStore.contextualProfiles;\n    const localCache: LRUCache<\n      FileID,\n      context.ContextualizedProfile[]\n    > = new LRUCache(MAX_CACHE_ENTRIES);\n\n    return (file: FileID) => {\n      // Generate a cache id\n      let cached = localCache.get(file);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      // Initialize our list to add valid profiles to\n      let profiles: context.ContextualizedProfile[] = [];\n\n      // Filter to those that match our filter. In this case that just means come from the right file id\n      this.dataStore.contextualProfiles.forEach(prof => {\n        if (isFromProfileFile(prof)) {\n          if (prof.from_file.unique_id === file) {\n            profiles.push(prof);\n          }\n        } else {\n          // Its a report; go two levels up to get its file\n          let ev = prof.sourced_from as SourcedContextualizedEvaluation;\n          if (ev.from_file.unique_id === file) {\n            profiles.push(prof);\n          }\n        }\n      });\n\n      return profiles;\n    };\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all controls from all profiles from the specified file id.\n   * Utlizes the profiles getter to accelerate the file filter.\n   */\n  get controls(): (filter: Filter) => readonly context.ContextualizedControl[] {\n    /** Cache by filter */\n    const depends = this.dataStore.contextualControls;\n    const localCache: LRUCache<\n      string,\n      readonly context.ContextualizedControl[]\n    > = new LRUCache(MAX_CACHE_ENTRIES);\n\n    return (filter: Filter = {}) => {\n      // Generate a hash for cache purposes.\n      // If the \"search_term\" string is not null, we don't cache - no need to pollute\n      let id: string = filter_cache_key(filter);\n\n      // Check if we have this cached:\n      let cached = localCache.get(id);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      // First get all of the profiles using the same filter\n      let profiles: readonly context.ContextualizedProfile[];\n      let controls: readonly context.ContextualizedControl[];\n      if (filter.fromFile !== undefined) {\n        // Get profiles\n        profiles = this.profiles(filter.fromFile);\n        // And all the controls they contain\n        controls = profiles.flatMap(profile => profile.contains);\n      } else {\n        // No file filter => we don't care about profile. Jump directly to the full control list\n        controls = this.dataStore.contextualControls;\n      }\n\n      // Filter by control id\n      if (filter.control_id !== undefined) {\n        controls = controls.filter(c => c.data.id === filter.control_id);\n      }\n\n      // Filter by status, if necessary\n      if (filter.status !== undefined) {\n        controls = controls.filter(\n          control => control.root.hdf.status === filter.status\n        );\n      }\n\n      // Filter by severity, if necessary\n      if (filter.severity !== undefined) {\n        controls = controls.filter(\n          control => control.root.hdf.severity === filter.severity\n        );\n      }\n\n      // Filter by overlay\n      if (filter.omit_overlayed_controls) {\n        controls = controls.filter(control => control.extended_by.length === 0);\n      }\n\n      // Filter by search term\n      if (filter.search_term !== undefined) {\n        let term = filter.search_term.toLowerCase();\n\n        // Filter controls to those that contain search term\n        controls = controls.filter(c => contains_term(c, term));\n      }\n\n      // Filter by nist stuff\n      if (filter.tree_filters && filter.tree_filters.length > 0) {\n        // Shorthand the nist filters\n        let f = filter.tree_filters;\n\n        // Construct a nist control to represent the filter\n        let control = new nist.NistControl(filter.tree_filters);\n\n        controls = controls.filter(c => {\n          // Get an hdf version so we have the fixed nist tags\n          return c.root.hdf.parsed_nist_tags.some(t => control.contains(t));\n        });\n      }\n\n      // Freeze and save to cache\n      let r = Object.freeze(controls);\n      localCache.set(id, r);\n      return r;\n    };\n  }\n}\n\nexport default FilteredDataModule;\n\n/**\n * Generates a unique string to represent a filter.\n * Does some minor \"acceleration\" techniques such as\n * - annihilating empty search terms\n * - defaulting \"omit_overlayed_controls\"\n */\nexport function filter_cache_key(f: Filter) {\n  // fix the search term\n  let new_search: string;\n  if (f.search_term !== undefined) {\n    new_search = f.search_term.trim();\n  } else {\n    new_search = \"\";\n  }\n\n  let new_f: Filter = {\n    search_term: new_search,\n    omit_overlayed_controls: f.omit_overlayed_controls || false,\n    ...f\n  };\n  return JSON.stringify(new_f);\n}\n"],"version":3}