{"file":"/Users/sjoshi/test/heimdall-lite/src/utilities/helper_util.ts","mappings":"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","names":[],"sources":["/Users/sjoshi/test/heimdall-lite/src/utilities/helper_util.ts"],"sourcesContent":["import InspecDataModule from \"@/store/data_store\";\nimport axios from \"axios\";\n\n/** For helper functions that don't belong anywhere else */\n\n/** Compares arrays a and b, returning a number indicating their lexicographic ordering\n * with the same output semantics.\n * That is,\n * a === b as determined by the comparator function, return 0;\n * if a is lexicographically before b, return < 0\n * if a is lexicographically after  b, return > 1\n */\nexport function compare_arrays<T>(\n  a: Array<T>,\n  b: Array<T>,\n  comparator: (a: T, b: T) => number\n) {\n  // Compare element-wise\n  for (let i = 0; i < a.length && i < b.length; i++) {\n    let x = comparator(a[i], b[i]);\n    if (x) {\n      return x;\n    }\n  }\n\n  // If we escape the loop, make final decision based on difference in length\n  if (a.length > b.length) {\n    // a longer => a after b => return positive\n    return 1;\n  } else if (a.length === b.length) {\n    // Completely equal\n    return 0;\n  } else {\n    // b longer => a before b => Return negative\n    return -1;\n  }\n}\n\n/** Returns two values: if we need to redirect, and if so to where  */\nexport function need_redirect_file(\n  curr_target: number | null,\n  data: InspecDataModule\n): \"ok\" | number | \"root\" {\n  // If we have no files, always exit\n  console.log(\"data.allFiles.length: \" + data.allFiles.length);\n  if (data.allFiles.length === 0) {\n    return \"root\";\n  }\n\n  console.log(\"curr_target: \" + curr_target);\n  // If we have no filter (IE \"all\" is our curr route), we already know there are files, so its fine\n  if (curr_target === null) {\n    return \"ok\";\n  }\n  // We have a filter: check it's valid\n  else {\n    data.allFiles.forEach(data_file => {\n      console.log(data_file.unique_id + \": \" + data_file.filename);\n    });\n    if (data.allFiles.some(f => f.unique_id === curr_target)) {\n      // This file exists\n      return \"ok\";\n    } else {\n      // Just go to first in list\n      return data.allFiles[0].unique_id;\n    }\n  }\n}\n\n/** Stores/retrives a simple JSON object from localstorage.\n * Will not store/retrieve methods - be advised! It won't work with class types!\n */\nexport class LocalStorageVal<T> {\n  private storage_key: string;\n\n  constructor(storage_key: string) {\n    this.storage_key = storage_key;\n  }\n\n  /** Retrieves the currently held item, as resolved by JSON.parse */\n  get(): T | null {\n    // Fetch the string, failing early if not set\n    let s = window.localStorage.getItem(this.storage_key);\n    if (!s) {\n      return null;\n    }\n\n    // Then try parsing. On fail, clear and go null\n    try {\n      let v = JSON.parse(s);\n      return v;\n    } catch (error) {\n      this.clear();\n      return null;\n    }\n  }\n\n  /** Wraps get, providing the provided default if necessary */\n  get_default(_default: T): T {\n    let v = this.get();\n    if (v === null) {\n      return _default;\n    } else {\n      return v;\n    }\n  }\n\n  /** Sets the local storage value to the given value, stringified */\n  set(val: T): void {\n    let nv = JSON.stringify(val);\n    window.localStorage.setItem(this.storage_key, nv);\n  }\n\n  /** Clears the local storage value */\n  clear(): void {\n    window.localStorage.removeItem(this.storage_key);\n  }\n}\n\n/** A useful shorthand */\nexport type Hash<T> = { [key: string]: T };\n\n/** Groups items by using the provided key function */\nexport function group_by<T>(\n  items: Array<T>,\n  key_getter: (v: T) => string\n): Hash<Array<T>> {\n  let result: Hash<Array<T>> = {};\n  for (let i of items) {\n    // Get the items key\n    let key = key_getter(i);\n\n    // Get the list it should go in\n    let corr_list = result[key];\n    if (corr_list) {\n      // If list exists, place\n      corr_list.push(i);\n    } else {\n      // List does not exist; create and put\n      result[key] = [i];\n    }\n  }\n  return result;\n}\n\n/** Maps a hash to a new hash, with the same keys but each value replaced with a new (mapped) value */\nexport function map_hash<T, G>(\n  old: Hash<T>,\n  map_function: (v: T) => G\n): Hash<G> {\n  let result: Hash<G> = {};\n  for (let key in old) {\n    result[key] = map_function(old[key]);\n  }\n  return result;\n}\n\n/** Converts a simple, single level json dict into uri params */\nexport function to_uri_params(params: Hash<string | number | boolean>) {\n  let esc = encodeURIComponent;\n  let query = Object.keys(params)\n    .map(k => esc(k) + \"=\" + esc(params[k]))\n    .join(\"&\");\n  return query;\n}\n\n/** Generate a basic authentication string for http requests */\nexport function basic_auth(username: string, password: string): string {\n  return \"Basic \" + Buffer.from(`${username}:${password}`).toString(\"base64\");\n}\n"],"version":3}