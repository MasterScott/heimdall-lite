{"version":3,"sources":["FileList.vue"],"names":[],"mappings":";;;;;;;;;AA0CA;;;;AACA;;;;AACA;;AACA;;AAUA;;;;;;AAEA;;AAEA;AACA;AACA;;AADA;AADA;;AASA;AAAA;;AACA;;AACA;AAEA;;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAFA;AAKA;AACA;AACA;AAHA;AAOA;;AACA;AAsCA;;AACA;AAEA;;AACA;AA2CA;;AACA;AAgBA;AApGA;;;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;;;;;;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAWA;;;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AAGA;;AACA;AAGA;AACA;;AAGA;;AAGA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AA7HA;AAAA;AAFA;AADA","sourcesContent":["<template>\n  <v-stepper-content step=\"2\">\n    <div class=\"d-flex flex-column\">\n      <v-data-table\n        :headers=\"headers\"\n        item-key=\"guid\"\n        :items=\"items\"\n        :search=\"search\"\n        :items-per-page=\"5\"\n      >\n        <template v-slot:top>\n          <v-toolbar>\n            <v-toolbar-title>Splunk Executions</v-toolbar-title>\n            <v-divider class=\"mx-4\" inset vertical></v-divider>\n            <v-spacer></v-spacer>\n            <v-text-field\n              v-model=\"search\"\n              append-icon=\"search\"\n              label=\"Search\"\n              single-line\n              hide-details\n            ></v-text-field>\n          </v-toolbar>\n        </template>\n        <template v-slot:item.action=\"{ item }\">\n          <v-icon @click=\"load_event(item)\">\n            mdi-plus-circle\n          </v-icon>\n        </template>\n        <template v-slot:no-data>\n          No data. Try relaxing your search conditions, or expanding the date\n          range.\n        </template>\n      </v-data-table>\n      <v-btn color=\"red\" @click=\"logout\" class=\"my-2\">\n        Logout\n      </v-btn>\n    </div>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport Vue from \"vue\";\nimport Component from \"vue-class-component\";\nimport { getModule } from \"vuex-module-decorators\";\nimport {\n  FileID,\n  next_free_file_ID,\n  EvaluationFile\n} from \"@/store/report_intake\";\nimport {\n  SplunkEndpoint,\n  ExecutionMetaInfo,\n  SplunkErrorCode\n} from \"../../../../utilities/splunk_util\";\nimport InspecDataModule from \"../../../../store/data_store\";\n\nconst SEARCH_INTERVAL = 10000;\n\nconst Props = Vue.extend({\n  props: {\n    endpoint: Object // Of type SplunkEndpoint. Can be null, but shouldn't be!\n  }\n});\n\n@Component({\n  components: {}\n})\nexport default class FileList extends Props {\n  /** The name written in the form */\n  search: string = \"\";\n\n  /** Table info */\n  headers = [\n    {\n      text: \"Filename\",\n      value: \"filename\",\n      filterable: true,\n      align: \"start\"\n    },\n    {\n      text: \"Time\",\n      value: \"start_time\"\n    },\n    {\n      text: \"Action\",\n      value: \"action\",\n      sortable: false\n    }\n  ];\n\n  /** Currently fetch'd executions */\n  items: ExecutionMetaInfo[] = [];\n\n  /** Typed getter for endpoint */\n  get _endpoint(): SplunkEndpoint | null {\n    if (this.endpoint == null) {\n      return null;\n    }\n    return this.endpoint as SplunkEndpoint;\n  }\n\n  /** Callback for when user selects a file.\n   * Loads it into our system.\n   * We assume we're auth'd if this is called\n   */\n  async load_event(event: ExecutionMetaInfo): Promise<void> {\n    // Get it out of the list\n    //let event = (null as unknown) as ExecutionMetaInfo;\n\n    // Get its full event list and reconstruct\n    return this._endpoint!.get_execution(event.guid)\n      .then(exec => {\n        let unique_id = next_free_file_ID();\n        let file = {\n          unique_id,\n          filename: `${event.filename} (Splunk)`,\n          execution: exec\n        } as EvaluationFile;\n        getModule(InspecDataModule, this.$store).addExecution(file);\n        this.$emit(\"got-files\", [unique_id]);\n      })\n      .catch(fail => {\n        this.$emit(\"error\", fail);\n      });\n  }\n\n  /** Passively searches */\n  searcher!: NodeJS.Timeout;\n\n  /** When we should next search. If curr time > this, then search*/\n  next_search_time: number = 0;\n\n  /** Are we already searching? Track here */\n  already_searching: boolean = false;\n\n  /** Updates search results, if it is appropriate to do so */\n  search_poller() {\n    if (!this._endpoint) {\n      return;\n    }\n\n    let curr_time = new Date().getTime();\n    if (curr_time > this.next_search_time && !this.already_searching) {\n      // As an initial venture, try again in 60 seconds. See below for our actual expected search\n      this.next_search_time = curr_time + 60000;\n\n      // Then do the search\n      this.already_searching = true;\n      this._endpoint\n        .fetch_execution_list()\n        .then(l => {\n          // On success, save the items\n          this.items = l;\n\n          // Mark search done\n          this.already_searching = false;\n\n          // And make the next try sometime sooner than the previous attempt\n          this.next_search_time = Math.min(\n            curr_time + SEARCH_INTERVAL,\n            this.next_search_time\n          );\n        })\n        .catch(error => {\n          this.items = [];\n          this.already_searching = false;\n          this.$emit(\"error\", error);\n        });\n    }\n  }\n\n  logout() {\n    this.$emit(\"exit-list\");\n    this.items = [];\n  }\n\n  /** Used for timer functions */\n  last_search_time: number = 0;\n  time_since_last_search(): number {\n    return new Date().getTime();\n  }\n\n  // Init search timers\n  mounted() {\n    this.searcher = setInterval(this.search_poller, 1000);\n  }\n\n  // Clear timer on destroy as well\n  beforeDestroy() {\n    if (this.searcher) {\n      clearInterval(this.searcher);\n    }\n  }\n}\n</script>\n"]}